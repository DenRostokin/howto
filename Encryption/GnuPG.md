Для установки используется комманда:

# apt-get install gnupg

Для генерации пары ключей используется комманда:

$ gpg --gen-key

После этого запрашивается различная информация. Для расширенного выбора параметров вместо --gen-key нужно использовать --full-generate-key. С этой опцией можно выбрать алгоритм шифрования, длину ключа и т.д.

Для просмотра всех созданных ключей используется комманда:

$ gpg --list-keys

На экран помимо всей остальной информации выводится также "отпечаток ключа" - хэш открытого ключа. Чтобы посмотреть хэши обоих ключей (pub и sub), используется комманда:

$ gpg --fingerprint --fingerprint

Также можно вывести идентификаторы ключей (key ID). Для этого используется комманда:

$ gpg --list-keys --keyid-format <none|short|long|etc.>

ID ключа это несколько последних символов отпечатка этого ключа!

---

Проверка подписи файла.

Для проверки подписи нужен сам файл, а также его подпись: это либо файла с расширением .sig (бинарный файл), либо файл с расширением .asc (текстовый файл в BASE64). Также для проверки подписи требуется, чтобы был импортирован в связку ключей gpg (keyring) публичный ключ, который соответствует секретному ключу, с помощью которого была сделана подпись. Если публичный ключ не был предоставлен в том месте, откуда мы скачали (или получили иным образом) сам файл и его подпись, то публичный ключ может быть скачан с keyserver'а. Для этого нужно получить отпечаток публичного ключа.

Проверка подписи осуществляется командой:

$ gpg --verify file_name.asc file_name

Если публичный ключ ещё не импортирован в связку ключей, то отобразится сообщение о том, что невозможно проверить подпись файла, т.к. нет соответсвующего публичного ключа в связке ключей. А также отобразится отпечаток отсутствующего публичного ключа.

Копируем этот отпечаток и вводим команду:

$ gpg --search-keys <pub_key_fingerprint>

Будет сделан запрос к keyserver'у (в моём случае это keyserver.ubuntu.com), и если публичный ключ с таким отпечатком существует, то он будет импортирован в нашу связку ключей.

После этого повторяем проверку подписи командой --verify. Должно быть выведено сообщение о том, что подпись действительна. Также в этом сообщении будет указано, что подпись сделана недоверенным ключом. Это означает то, что мы не подписали своим закрытым ключом импортированный публичный ключ. Это делать необязательно, но если мы в самом деле доверяем владельцу публичного ключа, то мы можем подписать его ключ командой:

$ gpg --sign-key <pub_key_fingerprint>

Можно получить публичный ключ не из keyserver'а, а скачать файл с этим ключом из сети. В том месте, что располагается ссылка с публичным ключом, обычно ещё указывается отпечаток этого ключа, что мы могли после скачивания проверить, что ключ не был подменён во время скачивания. Для этого используется команда:

$ gpg --show-keys <public_key_file.(asc|sig)>

Будет выведена информация о данном ключе, включая его отпечаток. Если ключ оригинальный, то его теперь можно импортировать в локальную связку ключей командой:

$ gpg --import <public_key_file.(asc|sig)>

---

Подпись файла.

Для подписи файла в локальной связке ключей должна быть пара ключей (публичный и секретный). Подписать файл можно разными способами. Можно сделать подпись, которая будет хранить внутри себя сами данные. Тогда для проверки этой подписи не нужен оригинальный файл. Данная процедура делается командой:

$ gpg --sign <file>

На выходе мы получим файл file.gpg. Это бинарный файл, который содержит подпись и сами данные. Проверка этого файла осуществляется командой:

$ gpg --verify <file.gpg>

Проблема здесь состоим в том, что если оригинальный файл был модифицирован злоумышленником перед скачиванием, мы этого не поймём, т.к. подпись проверяется у оригинального файла внутри file.gpg.

Чтобы сделать подпись файла отдельно от данных, используется команда:

$ gpg --detach-sign <file>

На выходе мы получаем бинарный файл file.sig, но внутри него уже нет данных оригинального файла, а значит и проверка подлинности должна происходить с использованием оригинального файла:

$ gpg --verify file.sig file

Последний параметр (file) можно не указывать, если имя файла совпадает с именем подписи (до расширения .sig), и этот файл  лежит рядом с файлом подписи.

Преимуществом подписи через --sign является то, что можно передать один только файл подписи, а уже потом извлечь из него оригинальные данные. Это делается командой:

$ gpg --output <result_file> --decrypt <file.gpg>

ВАЖНО! это не зашифрованный файл, а просто подписанный. Его может расшифровать кто угодно, у кого есть соответствующий публичный ключ.

---

Для шифрования файла с сообщением испльзуется комманда:

$ gpg --encrypt --recipient '<user_name|email>' <file_name>

На выходе получится файл <file_name>.gpg. Это бинарный файл. Чтобы получить файл в ASCII-кодировке, нужно указать ключ --armor:

$ gpg --encrypt --recipient '<user_name|email>' --armor <file_name>

Тогда на выходе будет файл <file_name>.asc. Для расшифровки сообщения используется комманда:

$ gpg --decrypt <file_name>

Расшифрованное сообщение будет выведено в консоль! Указав опцию --output можно вывести сообщение в файл.

---

Чтобы экспортировать публичный ключ в файл в ASCII-формате используется комманда:

$ gpg --armor --export <email> > <file_name>.asc

Или:

$ gpg --output <path_to_output_file>.key --export --armor <email>

Расширение конечного файла не играет роли, и выбирается на усмотрение!

---

Для удаления пары ключей сначала нужно удалить приватный ключ:

$ gpg --delete-secret-keys <key ID|user_name|email>

После этого можно удалить публичный ключ:

$ gpg --delete-key <key ID|user_name|email>

PS: данные взяты из статьи https://medium.com/@acparas/gpg-quickstart-guide-d01f005ca99
